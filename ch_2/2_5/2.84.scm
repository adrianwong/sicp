; Install into respective packages
(put 'level 'scheme-number 1)
(put 'level 'rational 2)
(put 'level 'real 3)
(put 'level 'polar 4)
(put 'level 'rectangular 4)
(put 'level 'complex 4)

(define (apply-generic op . args)
  (define (coerce-to-type type arg)
    (let ((lvl1 (get 'level type))
          (lvl2 (get 'level (type-tag arg))))
      (if (< lvl2 lvl1)
          (coerce-to-type type ((get 'raise (type-tag arg))
                                (contents arg)))
          arg)))
  (define (coerce-args type args)
    (map (lambda (x) (coerce-to-type type x)) args))
  (define (apply-coerced types)
    (if (null? types)
        (error "No method for these types")
        (let ((coerced-args (coerce-args (car types) args)))
          (let ((proc (get op (map type-tag coerced-args))))
            (if proc
                (apply proc (map contents coerced-args))
                (apply-coerced (cdr types)))))))
  (let ((type-tags (map type-tag args)))
    (apply-coerced type-tags)))

; Tests
(apply-generic 'mul (make-scheme-number 2) (make-scheme-number 4))
; '(scheme-number . 8)
(apply-generic 'sub (make-real 6) (make-rational 3 2))
; '(real . 4.5)
(apply-generic 'add (make-scheme-number 1) (make-complex-from-real-imag 2 7))
; '(complex rectangular 3.0 . 7)
